---
title: http 和 https
lastUpdated: true
---

# http 和 https

https://mp.weixin.qq.com/s/pqVIluP4NxBJ3yNBSphqrQ
https://mp.weixin.qq.com/s/vIWtaS4RaaX25j2g-m6wDw
https://mp.weixin.qq.com/s/HwkHm-1yhaykrpycyBjelw

## http

HyperText Transfer Protocol 应用层协议

http 0.9 功能比较单一
http 1.0 拓展了 headers，默认每一对 HTTP 请求/响应都打开一个单独的 TCP 连接，

现在最主流使用的是 http1.1

### 基础特性

- 可拓展，http 1.0 之后就可以拓展了，只要服务端与客户端就 headers 达成语义一致，新功能就可以添加
- 是无状态的，同一个连接中两个执行成功的 http 请求之间是没有关系的（使用 cookie 和 session 解决这个问题）
- 面向连接，通过 TCP 连接（或者 TLS ，加密的 TCP）来发送，理论上任何可靠的传说协议都可以使用，连接是传输层控制的

http 组件系统包括：

- 客户端
- web 服务端
- 代理：可以缓存、过滤、负载均衡、认证、日志管理等

### HTTP 请求和响应

典型的 http 会话过程：

- 客户端发起建立连接，使用 TCP 时，http 默认端口号是 80
- 发送客户端请求
- 服务器响应请求

http 请求和响应都包括：

- start line（起始行）
  - 请求的起始行包括：
    - 请求方法
    - 请求 path：可以使用绝对路径，完整 url，域名和可选端口，星花（\*代表整个服务器，一般配合 OPTION 使用）
    - http 版本号
  - 响应的起始行包括：
    - http 版本号
    - 响应状态码
    - 状态文本描述（可以省略）
- http headers（请求头/响应头）：不区分大小写的字符串紧跟着冒号和一个值
- empty line（空行）
- body 部分

#### 请求方法

请求方法：方法是否安全方法及其用法都是约定俗称，实际使用还是看 web 服务器的开发者决定

- GET：请求服务器发送某个资源
- HEAD：与 GET 类似，但是只返回首部，不返回报文主体
- POST：向服务器输入数据
- PUT：向服务器写入
- TRACE：诊断目标资源路径的消息回还
- OPTIONS：请求服务器告知其支持的各种功能 （为什么会自动发送 OPTIONS）
- DELETE：请求删除指定资源

#### GET 和 POST 的区别

应用场景上，get 是无副作用的，幂等的，post 主要是有副作用的，不幂等的

技术上：

- 缓存：Get 请求能缓存，Post 请求不能
- 安全：Get 请求的参数在 url 里，相对不安全，还会被保存历史记录
- 限制：url 有长度限制，会干预 get 请求不能
- 编码：GET 只能进行 url 编码，只能接收 ASCII 字符，POST 没有限制
- 从 TCP 角度看：GET 请求会把请求报文一次性发出去，而 POST 会分成两个数据包，首先发 header 部分，如果服务器响应 100，然后发 body 包（火狐浏览器除外）

#### 状态码

- 100 ～ 199 信息性状态码
- 200 ～ 299 成功
- 300 ～ 399 重定向
  - 301 moved permanently 永久重定向
  - 302 found 临时重定向
  - 303 see other 资源存在另一个 url 应使用 Get
  - 304 not modified 可以用缓存
- 400 ～ 499 客户端错误
  - 400 bad request，请求报文存在语法错误
  - 401 unauthorized，请求需要有通过 http 认证的认证信息
  - 403 forbidden，请求被拒绝
  - 404 not found 服务器上没有找到资源
- 500 ～ 599 服务器错误
  - 500 internal server error 服务器发生错误
  - 501 not implemented 服务器不支持当前请求所需要的某个功能
  - 503 service unavailable 服务器超载或停机维护

#### 首部

### http 0.9 / 1.0 / 1.1 / 2.0

- 0.9 没有响应头，没有状态码，只传输 html 文件
- 1.0 有状态码，content-type 告诉客户端返回的内容类型，但是每个 TCP 只能发送一个 http 请求

http 1.1

- 连接可复用：默认开启长连接 connection: keep-alive ，一个 TCP 连接上可以传送多个 HTTP 请求和响应
- 增加了管道化技术：还是存在队头阻塞问题
- 支持响应分块
- 引入额外的缓存控制机制：1.0 里主要使用 If-Modified-Sinc、Expires 判断，1.1 引入了 Entity tag、If-None-Match、Cache-Control 等
- Host 头，不同域名配置同一个 IP 地址等服务器

http 2.0

- 是二进制协议，而不是文本协议
  - 帧：是这个协议通信的最小单位
  - 消息：比如请求、响应，由一或多个帧组成
  - 流：虚拟信道
- 多路复用：分成多个帧发送

### http 缓存

#### 强缓存

由 Cache-Control 和 Expires 决定

Cache-Control: max-age=31536000

#### 协商缓存

## https

### 加密

#### 单向加密

不可逆加密，对明文产生一个密文，并不能再通过密文解出来对应的明文

但是输入一样时输出必然相同

一般用于产生消息摘要，密钥加密、保存验证密码等，比如 md5，SHA

#### 对称加密

用一个密钥，对明文进行加密，再用同一个密钥进行解密

比如 DES 3DES AES

#### 非对称加密

使用私钥进行加密，使用公钥进行解密，也可以使用公钥加密，私钥解密

比如 RSA DSA

特点：

- 使用两把密钥进行加密和解密
- 一个加密要用另一个解密
- 加密和解密速度慢
- 私钥和公钥总是成对出现

#### 进行通讯的场景

如果直接使用非对称加密进行通讯，会非常慢，所以需要使用对称加密的方式进行

但是对称加密的密钥在传输过程中可能被截取，然后中间人就可以用密钥解密双方消息再加密转发

所以这个对称加密使用的密钥需要安全传输，就用 非对称加密来传输对称加密使用的密钥

A 和 B 之间进行非对称加密传输，可以让 B 获取 A 的公钥（公钥是公开的，其他人很容易获取），加密数据后发送给 A，A 再用自己的私钥进行解密

**但是这样依旧存在中间人攻击的可能性**

C 有自己的公钥和私钥，在 B 获取 A 的公钥的过程中进行拦截，让 B 获取的是 C 的公钥，然后 B 发送密钥时使用的其实是 C 的公钥，然后 C 进行拦截，用私钥解密，保存一份，然后将密钥使用 A 的公钥进行加密转发给 A，A 用私钥解密，这样 C 就可以监听 A B 之间的通信了

**数字证书就是为了解决公钥传输问题的**

- 摘要：md5 或者其他单向加密算法对内容进行加密，得到的字符串就叫摘要
- 签名：用私钥对摘要进行加密，加密出来的字符串就叫签名
- 验签：用对方公钥对签名进行解密操作，解密的摘要和原来的对比，就叫验签

数字证书中包含了：

- 1.公钥：使用者的公钥
- 2.颁发者：CA（证书认证机构）
- 3.有效期：证书的使用期限
- 4.摘要算法：指定摘要算法，用来计算证书的摘要
- 5.指纹：也就是证书的摘要，用来验证证书的完整性
- 6.序列号：证书的唯一标识

然后在前面的例子里，A 有了证书，B 就不用去下载 A 的公钥的，直接 A 传输证书给 B 即可
B 要验证 证书的真实性，就需要用 CA 机构的公钥进行解密，而 CA 机构的公钥不需要去下载，CA 机构的数字证书会内置在操作系统中
此时，B 使用 CA 机构的公钥对 A 传输来的证书里的签名进行解密，得到摘要，然后根据证书的摘要算法进行计算，对比摘要是否相等，如果相等，就说明证书是 CA 机构颁布的

### https 通信的完整过程

- 前置步骤
  - 1. 网站向 CA 机构 申请数字证书
  - 2. CA 机构用自己的私钥加密数字证书并签名，数字证书中存有网站的公钥，将数字证书颁发给对应网站
- 开始通信
  - 3. 浏览器向服务器发送加密请求
  - 4. 服务器响应浏览器，把加密的网页和数字证书一起发送给浏览器
  - 5. 浏览器获取网站的数字证书，对数字证书进行验证，确认是 CA 机构颁发的证书后，使用数字证书中的网站公钥和服务器协商一个对称加密的密钥即可，然后再次访问网站，这个过程就是对称加密了
