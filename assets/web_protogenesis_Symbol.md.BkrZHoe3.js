import{_ as i,c as l,a2 as a,o as e}from"./chunks/framework.DOgdC_ou.js";const b=JSON.parse('{"title":"Symbol","description":"","frontmatter":{"title":"Symbol","lastUpdated":true},"headers":[],"relativePath":"web/protogenesis/Symbol.md","filePath":"web/protogenesis/Symbol.md","lastUpdated":1729515322000}'),o={name:"web/protogenesis/Symbol.md"};function t(p,s,n,d,r,c){return e(),l("div",null,s[0]||(s[0]=[a(`<h1 id="symbol" tabindex="-1">Symbol <a class="header-anchor" href="#symbol" aria-label="Permalink to &quot;Symbol&quot;">​</a></h1><p><code>symbol</code> 是一种基本数据类型（primitive data type）。<code>Symbol()</code> 函数会返回 <code>symbol</code> 类型的值</p><p><strong>每个从 <code>Symbol</code> 返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([description]);</span></span></code></pre></div><p>description 可选，是对 symbol 的描述，可以用于调试但不是访问 symbol 本身，不管描述是否相同，是否存在，每次都会创建一个新的 symbol 类型</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>ECMAScript 6 开始，围绕原始类型创建一个显示的包装类型就不被支持了，<code>new Symbol</code> 会报错 TypeError，<code>new Boolean()</code> <code>new String()</code> <code>new Number()</code> 因为历史遗留原因仍可用</p></div><h2 id="全局共享的-symbol" tabindex="-1">全局共享的 Symbol <a class="header-anchor" href="#全局共享的-symbol" aria-label="Permalink to &quot;全局共享的 Symbol&quot;">​</a></h2><p><code>Symbol.for()</code> 从全局的 symbol 注册表设置，确保多个模块间共享某个 Symbol 值时唯一，如果已有则返回该 symbol 值，如果没有则创建一个新的并返回</p><p><code>Symbol.keyFor()</code> 从全局的 symbol 注册表取得，不存在则返回 <code>undefined</code>，存在则返回描述值</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>全局是指什么范围呢？计算机？当前页面？当前浏览器 tab 页面进程？当前的作用域？</p></div><h2 id="在对象中查找-symbol-属性" tabindex="-1">在对象中查找 Symbol 属性 <a class="header-anchor" href="#在对象中查找-symbol-属性" aria-label="Permalink to &quot;在对象中查找 Symbol 属性&quot;">​</a></h2><p><code>Object.getOwnPropertySymbols()</code> 方法，查找一个给定对象的 symbol 属性，返回一个 symbol 类型的数组</p><h2 id="属性" tabindex="-1">属性 <a class="header-anchor" href="#属性" aria-label="Permalink to &quot;属性&quot;">​</a></h2><ul><li>Symbol.length 值为 0</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Symbol.length 有什么用</p></div><ul><li>Symbol.prototype.toString()</li><li>Symbol.prototype.valueOf() 返回 Symbol 值本身</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ss </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sss&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ss </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ss.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">valueOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span></code></pre></div><h2 id="用途" tabindex="-1">用途 <a class="header-anchor" href="#用途" aria-label="Permalink to &quot;用途&quot;">​</a></h2><ul><li>是唯一的</li><li>可以用作对象属性名，不会被意外覆盖</li><li>作为私有属性来使用，无法通过对象外部访问对象中的 Symbol 属性</li><li>常量</li></ul>`,19)]))}const m=i(o,[["render",t]]);export{b as __pageData,m as default};
