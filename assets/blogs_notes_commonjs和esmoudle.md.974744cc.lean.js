import{_ as o,c as t,o as s,a as e,b as n}from"./app.9f00edf1.js";const J=JSON.parse('{"title":"CommonJS 和 ESModule","description":"","frontmatter":{"title":"CommonJS 和 ESModule","lastUpdated":true},"headers":[],"relativePath":"blogs/notes/commonjs和esmoudle.md","lastUpdated":1704785209000}'),d={name:"blogs/notes/commonjs和esmoudle.md"},a=e("h1",{id:"commonjs-和-esmodule",tabindex:"-1"},[n("CommonJS 和 ESModule "),e("a",{class:"header-anchor",href:"#commonjs-和-esmodule","aria-hidden":"true"},"#")],-1),m=e("p",null,"一个是导出一份值的拷贝，一个是导出值的引用；一个运行时加载，一个是静态编译时加载",-1),l=e("p",null,"CommonJS 通过模块缓存的方法解决循环引用问题，先检查是否有缓存，已有则不会进入执行，在模块缓存中记录导出的变量的拷贝值",-1),c=e("p",null,"ESModule 通过 模块地图 和 模块记录，一句进入过的模块标注为 fetching，遇到 import 语句会去检查这个地图，已经标注为获取中（fetching）则不会进入，地图每个节点是一个模块记录，上面有导出变量的内存地址，导入时会做一个连接，指向同一块内存",-1),r=e("p",null,"查找模块时，核心模块和文件模块都比较简单，第三方模块会从最近的 node_module 开始，递归往上找，找到包后根据 package.json 的 main 字段找到入口文件",-1),_=e("p",null,"CommonJS 的 module.export 和 export 指向同一块内存，但是由于最后导出的是 module.export 所以不能直接给 export 赋值，会导致指向丢失",-1),i=[a,m,l,c,r,_];function p(u,h,f,S,x,g){return s(),t("div",null,i)}const C=o(d,[["render",p]]);export{J as __pageData,C as default};
