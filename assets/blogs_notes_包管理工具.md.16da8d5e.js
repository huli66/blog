import{_ as e,c as a,o as n,d as t}from"./app.d1919d64.js";const u=JSON.parse('{"title":"包管理工具","description":"","frontmatter":{"title":"包管理工具","lastUpdated":true},"headers":[{"level":2,"title":"npm","slug":"npm","link":"#npm","children":[]},{"level":2,"title":"yarn","slug":"yarn","link":"#yarn","children":[]},{"level":2,"title":"pnpm","slug":"pnpm","link":"#pnpm","children":[]}],"relativePath":"blogs/notes/包管理工具.md","lastUpdated":1692005866000}'),r={name:"blogs/notes/包管理工具.md"},p=t('<h1 id="包管理工具" tabindex="-1">包管理工具 <a class="header-anchor" href="#包管理工具" aria-hidden="true">#</a></h1><h2 id="npm" tabindex="-1">npm <a class="header-anchor" href="#npm" aria-hidden="true">#</a></h2><p>早期 v2 版本，依赖包重复安装，嵌套层级太深</p><p>v3 版本提出了目录扁平化，将第一次安装的某个版本提升到顶层，其他版本无法提升到顶层就不变，缓解了嵌套层级太深的问题 但是产生了幽灵依赖问题、双胞胎陌生人问题（B v1 被提升到顶层，下面两个包都依赖 B v2，则依旧会重复安装 B v2，哪个包提升到顶层也和安装顺序有关，并不稳定，依赖不幂等） 为了解决依赖不幂等的问题，就使用了锁文件的方案，yarn 最早提出（yarn.lock package-lock.json)</p><h2 id="yarn" tabindex="-1">yarn <a class="header-anchor" href="#yarn" aria-hidden="true">#</a></h2><p>yarn 也存在幽灵依赖问题，但是多个版本包更智能</p><h2 id="pnpm" tabindex="-1">pnpm <a class="header-anchor" href="#pnpm" aria-hidden="true">#</a></h2><p>解决了幽灵依赖问题</p><p>hard link：pnpm 安装过程中会在全局的 store 目录中存储依赖包，然后在项目对应的 node_modules 中创建相应的硬链接</p><p>存在兼容性问题，或者某些 npm 包中写死了引用路径，可能会导致出错，而且依赖包在全局 store 中维护，修改调试时所有工程都会受影响</p>',10),d=[p];function s(i,l,o,c,h,_){return n(),a("div",null,d)}const f=e(r,[["render",s]]);export{u as __pageData,f as default};
