import{_ as s,c as a,o as e,d as n}from"./app.4b4450fa.js";const F=JSON.parse('{"title":"websocket重构和状态检测","description":"","frontmatter":{"title":"websocket重构和状态检测","lastUpdated":true},"headers":[{"level":2,"title":"问题背景","slug":"问题背景","link":"#问题背景","children":[]},{"level":2,"title":"解决思路","slug":"解决思路","link":"#解决思路","children":[]},{"level":2,"title":"问题和难点","slug":"问题和难点","link":"#问题和难点","children":[]},{"level":2,"title":"实现过程","slug":"实现过程","link":"#实现过程","children":[{"level":3,"title":"封装一个 createWebSocket 方法","slug":"封装一个-createwebsocket-方法","link":"#封装一个-createwebsocket-方法","children":[]},{"level":3,"title":"closeWebSocket 方法","slug":"closewebsocket-方法","link":"#closewebsocket-方法","children":[]},{"level":3,"title":"subscribeMessage 方法","slug":"subscribemessage-方法","link":"#subscribemessage-方法","children":[]},{"level":3,"title":"unSubscribeMessage 方法","slug":"unsubscribemessage-方法","link":"#unsubscribemessage-方法","children":[]},{"level":3,"title":"heartBeat","slug":"heartbeat","link":"#heartbeat","children":[]},{"level":3,"title":"changeStatus","slug":"changestatus","link":"#changestatus","children":[]}]}],"relativePath":"blogs/websocket重构和状态检测.md","lastUpdated":1690719973000}'),l={name:"blogs/websocket重构和状态检测.md"},t=n(`<h1 id="websocket-重构和状态检测" tabindex="-1">websocket 重构和状态检测 <a class="header-anchor" href="#websocket-重构和状态检测" aria-hidden="true">#</a></h1><h2 id="问题背景" tabindex="-1">问题背景 <a class="header-anchor" href="#问题背景" aria-hidden="true">#</a></h2><p>websocket 连接较多且分散，不同组件调用相同或不同的 websocket，重复连接消耗性能</p><p>断开重连后不需要刷新页面重新连接，断开重连后事件保持</p><p>网络断开不会触发 onclose 和 onerror，需要添加状态检测功能</p><h2 id="解决思路" tabindex="-1">解决思路 <a class="header-anchor" href="#解决思路" aria-hidden="true">#</a></h2><p>统计所有连接，部分常用的连接（比如系统信息包括服务端时间） 一个文件维护所有订阅的标识及其 url</p><p>解藕 websocket 和事件</p><p>系统打开时 批量订阅常用部分</p><h2 id="问题和难点" tabindex="-1">问题和难点 <a class="header-anchor" href="#问题和难点" aria-hidden="true">#</a></h2><p>类型需要通用</p><p>状态变化比较多（考虑了存在 ref 里和 state 里）</p><h2 id="实现过程" tabindex="-1">实现过程 <a class="header-anchor" href="#实现过程" aria-hidden="true">#</a></h2><p>枚举所有连接，16 位二进制（最开始是字符串，但是维护操作不方便），方便状态检测</p><p>socketMap</p><p>callbackMap</p><h3 id="封装一个-createwebsocket-方法" tabindex="-1">封装一个 createWebSocket 方法 <a class="header-anchor" href="#封装一个-createwebsocket-方法" aria-hidden="true">#</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> createWebSocket </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">props</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">socketServer</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">SocketServer</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">onStatusChange</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">socketServer</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">SocketServer</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">flag</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">boolean</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">void</span><span style="color:#89DDFF;">):</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">void</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 1.创建</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 2.给 onerror onclose 事件添加重连和改变状态功能</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 3.onopen 添加心跳检测功能</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 4.onmessage 添加事件处理</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h3 id="closewebsocket-方法" tabindex="-1">closeWebSocket 方法 <a class="header-anchor" href="#closewebsocket-方法" aria-hidden="true">#</a></h3><p>清除单个，清除整个 map</p><h3 id="subscribemessage-方法" tabindex="-1">subscribeMessage 方法 <a class="header-anchor" href="#subscribemessage-方法" aria-hidden="true">#</a></h3><p>如果已经订阅了，那么就直接添加 callbackmap 如果没有就创建新连接，添加 socketmap 和 callbackMap</p><h3 id="unsubscribemessage-方法" tabindex="-1">unSubscribeMessage 方法 <a class="header-anchor" href="#unsubscribemessage-方法" aria-hidden="true">#</a></h3><p>socketMap 删除对应 socketServer 的一个 id，callbackMap 删除对应 id</p><h3 id="heartbeat" tabindex="-1">heartBeat <a class="header-anchor" href="#heartbeat" aria-hidden="true">#</a></h3><h3 id="changestatus" tabindex="-1">changeStatus <a class="header-anchor" href="#changestatus" aria-hidden="true">#</a></h3><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> changeStatus </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">socketServer</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">SocketServer</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">flag</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">boolean</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">flag</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 移除标志</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 添加标志，按位与</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span></code></pre></div><p>位运算的优势，重复计算不会改变结果，不会改变状态就不会导致 refresh</p><p>status 作为一个需要全局查看的状态，放在 App.tsx 里，一个 state 变化了就进行一次计算 判断状态，只需要所有都进行位运算是否为 NoFlags</p>`,29),o=[t];function p(c,r,i,y,D,h){return e(),a("div",null,o)}const b=s(l,[["render",p]]);export{F as __pageData,b as default};
