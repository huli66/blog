import{_ as e,c as a,o as l,d as i}from"./app.9f00edf1.js";const _=JSON.parse('{"title":"权限系统","description":"","frontmatter":{"title":"权限系统","lastUpdated":true},"headers":[{"level":2,"title":"ACL 模型：访问控制列表","slug":"acl-模型-访问控制列表","link":"#acl-模型-访问控制列表","children":[]},{"level":2,"title":"DAC 模型：自主访问控制","slug":"dac-模型-自主访问控制","link":"#dac-模型-自主访问控制","children":[]},{"level":2,"title":"MAC 模型：强制访问控制","slug":"mac-模型-强制访问控制","link":"#mac-模型-强制访问控制","children":[]},{"level":2,"title":"ABAC 模型：基于属性的访问控制","slug":"abac-模型-基于属性的访问控制","link":"#abac-模型-基于属性的访问控制","children":[]},{"level":2,"title":"RBAC：基于角色的权限访问控制","slug":"rbac-基于角色的权限访问控制","link":"#rbac-基于角色的权限访问控制","children":[]},{"level":2,"title":"公司权限系统","slug":"公司权限系统","link":"#公司权限系统","children":[]}],"relativePath":"blogs/problems/权限系统.md","lastUpdated":1704785209000}'),r={name:"blogs/problems/权限系统.md"},t=i('<h1 id="权限系统" tabindex="-1">权限系统 <a class="header-anchor" href="#权限系统" aria-hidden="true">#</a></h1><p><a href="https://mp.weixin.qq.com/s/jXbRj4pitWDSu-32V9a4jg" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/jXbRj4pitWDSu-32V9a4jg</a></p><ul><li>ACL 模型 访问控制列表</li><li>DAC 模型 自主访问控制</li><li>MAC 模型 强制访问控制</li><li>ABAC 模型 基于属性的访问控制</li><li>RBAC 模型 基于角色的权限访问控制</li></ul><h2 id="acl-模型-访问控制列表" tabindex="-1">ACL 模型：访问控制列表 <a class="header-anchor" href="#acl-模型-访问控制列表" aria-hidden="true">#</a></h2><p>Access Control List，最早最基本的一种访问控制机制</p><p>原理：每个客体都有一个列表，记录哪些主体可以对这个客体做哪些行为</p><p>比如 用户 A 要编辑一篇文章，ACL 会检查文章的控制列表用没有 A 用户，有没有编辑权限</p><p>缺点：主体较多时配置和维护工作成本大</p><h2 id="dac-模型-自主访问控制" tabindex="-1">DAC 模型：自主访问控制 <a class="header-anchor" href="#dac-模型-自主访问控制" aria-hidden="true">#</a></h2><p>Discretionary Access Control，DAC 是 ACL 的一种扩展</p><p>原理：在 ACL 模型的基础上，允许主体将自己拥有的权限自主授予其他主体</p><p>例如 Linux 的文件系统权限</p><p>缺点：对权限控制比较分散，主体权限太大，容易泄漏信息</p><h2 id="mac-模型-强制访问控制" tabindex="-1">MAC 模型：强制访问控制 <a class="header-anchor" href="#mac-模型-强制访问控制" aria-hidden="true">#</a></h2><p>Mandatory Access Control，MAC 模型中主要的是双向验证机制</p><p>原理：主体有一个权限标识，客体有一个权限标识，能否操作取决于双方权限标识的关系</p><p>例如：将军分为 上将 &gt; 中将 &gt; 少将，军事文件保密等级分为 绝密 &gt; 机密 &gt; 秘密</p><p>缺点：控制太严格，实现工作量大，缺乏灵活性</p><h2 id="abac-模型-基于属性的访问控制" tabindex="-1">ABAC 模型：基于属性的访问控制 <a class="header-anchor" href="#abac-模型-基于属性的访问控制" aria-hidden="true">#</a></h2><p>Attribute-Based Access Control，能够很好地解决 RBAC 的缺点，在新增资源时容易维护</p><p>原理：通过动态计算一个或一组属性是否满足某种机制来授权，是一种很灵活的权限模型，可以按需实现不同颗粒度的权限控制</p><p>属性通常有 4 类</p><ul><li>主体属性：用户属性，年龄、性别</li><li>客体属性：如一篇文章</li><li>环境属性：空间限制、时间限制、频度限制</li><li>操作属性：行为类型，只读、读写等</li></ul><p>例如：早上 9:00 ～ 11:00 A、B 两个部门一起以考生的身份考试，下午 14:00 ～ 17:00 两个部门相互阅卷</p><p>缺点：规则复杂，不易看出主体客体之间的关系，实现非常难，现实应用比较少（比如高考阅卷）</p><h2 id="rbac-基于角色的权限访问控制" tabindex="-1">RBAC：基于角色的权限访问控制 <a class="header-anchor" href="#rbac-基于角色的权限访问控制" aria-hidden="true">#</a></h2><p>Role-Based Access Control，核心在于用户只和角色关联，角色代表对应权限，是一些列权限的集合</p><p>RBAC 三要素：</p><ul><li>用户：系统中所有的账户</li><li>角色：一些列权限的集合，如管理员，开发者等</li><li>权限：菜单，按钮等的增删改查权限</li></ul><p>优点：便于角色划分，更灵活授权管理，最小颗粒度授权</p><p>RBAC0 用户、角色、权限 都是多对多关系</p><p>RBAC1 基于 RBAC0 增加了角色分级的逻辑</p><p>RBAC2 对角色有更多的限制，例如 角色互斥、角色数量限制</p><p>RBAC3 具有 RBAC1 和 RBAC2 的所有特点，由 用户管理、角色管理、权限管理 三大部分</p><h2 id="公司权限系统" tabindex="-1">公司权限系统 <a class="header-anchor" href="#公司权限系统" aria-hidden="true">#</a></h2><p>分为 permission 和 resource</p><p>permission 为了让用户更方便操作权限配置</p><p>resource 作为前端显示权限（这样就不用在配置某个页面的时候考虑是否需要配置前置权限）</p>',38),p=[t];function c(s,d,n,h,o,A){return l(),a("div",null,p)}const u=e(r,[["render",c]]);export{_ as __pageData,u as default};
