import{_ as e,c as a,o as t,d}from"./app.64eb0b16.js";const f=JSON.parse('{"title":"排序数组中查找数字","description":"","frontmatter":{"title":"排序数组中查找数字","lastUpdated":true},"headers":[{"level":2,"title":"题目","slug":"题目","link":"#题目","children":[]},{"level":2,"title":"思路","slug":"思路","link":"#思路","children":[]},{"level":2,"title":"实现","slug":"实现","link":"#实现","children":[]}],"relativePath":"developer/algorithms/查找/排序数组中查找数字.md","lastUpdated":1686121174000}'),r={name:"developer/algorithms/查找/排序数组中查找数字.md"},i=d('<h1 id="排序数组中查找数字" tabindex="-1">排序数组中查找数字 <a class="header-anchor" href="#排序数组中查找数字" aria-hidden="true">#</a></h1><h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-hidden="true">#</a></h2><p>统计一个数字在一个排序数组中出现的次数</p><h2 id="思路" tabindex="-1">思路 <a class="header-anchor" href="#思路" aria-hidden="true">#</a></h2><p>思路一：双指针，既然是有序，那就找到第一个和最后一个，然后计算之间有几个，时间复杂度 <code>O(n)</code> 思路二：二分查找，找到目标值，然后向前向后遍历，时间复杂度 <code>O(n)</code> 思路三：二分查找，找到第一个和最后一个，时间复杂度 <code>O(logn)</code></p><h2 id="实现" tabindex="-1">实现 <a class="header-anchor" href="#实现" aria-hidden="true">#</a></h2>',6),n=[i];function l(o,c,s,_,h,p){return t(),a("div",null,n)}const m=e(r,[["render",l]]);export{f as __pageData,m as default};
