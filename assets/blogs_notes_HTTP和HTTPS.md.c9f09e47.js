import{_ as l,c as i,o as t,d as e}from"./app.90c1412e.js";const f=JSON.parse('{"title":"http 和 https","description":"","frontmatter":{"title":"http 和 https","lastUpdated":true},"headers":[{"level":2,"title":"http","slug":"http","link":"#http","children":[{"level":3,"title":"基础特性","slug":"基础特性","link":"#基础特性","children":[]},{"level":3,"title":"HTTP 请求和响应","slug":"http-请求和响应","link":"#http-请求和响应","children":[]},{"level":3,"title":"http 0.9 / 1.0 / 1.1 / 2.0","slug":"http-0-9-1-0-1-1-2-0","link":"#http-0-9-1-0-1-1-2-0","children":[]},{"level":3,"title":"http 缓存","slug":"http-缓存","link":"#http-缓存","children":[]}]},{"level":2,"title":"https","slug":"https","link":"#https","children":[{"level":3,"title":"加密","slug":"加密","link":"#加密","children":[]},{"level":3,"title":"https 通信的完整过程","slug":"https-通信的完整过程","link":"#https-通信的完整过程","children":[]}]}],"relativePath":"blogs/notes/HTTP和HTTPS.md","lastUpdated":1695209990000}'),a={name:"blogs/notes/HTTP和HTTPS.md"},h=e('<h1 id="http-和-https" tabindex="-1">http 和 https <a class="header-anchor" href="#http-和-https" aria-hidden="true">#</a></h1><p><a href="https://mp.weixin.qq.com/s/pqVIluP4NxBJ3yNBSphqrQ" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/pqVIluP4NxBJ3yNBSphqrQ</a><a href="https://mp.weixin.qq.com/s/vIWtaS4RaaX25j2g-m6wDw" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/vIWtaS4RaaX25j2g-m6wDw</a><a href="https://mp.weixin.qq.com/s/HwkHm-1yhaykrpycyBjelw" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/HwkHm-1yhaykrpycyBjelw</a></p><h2 id="http" tabindex="-1">http <a class="header-anchor" href="#http" aria-hidden="true">#</a></h2><p>HyperText Transfer Protocol 应用层协议</p><p>http 0.9 功能比较单一 http 1.0 拓展了 headers，默认每一对 HTTP 请求/响应都打开一个单独的 TCP 连接，</p><p>现在最主流使用的是 http1.1</p><h3 id="基础特性" tabindex="-1">基础特性 <a class="header-anchor" href="#基础特性" aria-hidden="true">#</a></h3><ul><li>可拓展，http 1.0 之后就可以拓展了，只要服务端与客户端就 headers 达成语义一致，新功能就可以添加</li><li>是无状态的，同一个连接中两个执行成功的 http 请求之间是没有关系的（使用 cookie 和 session 解决这个问题）</li><li>面向连接，通过 TCP 连接（或者 TLS ，加密的 TCP）来发送，理论上任何可靠的传说协议都可以使用，连接是传输层控制的</li></ul><p>http 组件系统包括：</p><ul><li>客户端</li><li>web 服务端</li><li>代理：可以缓存、过滤、负载均衡、认证、日志管理等</li></ul><h3 id="http-请求和响应" tabindex="-1">HTTP 请求和响应 <a class="header-anchor" href="#http-请求和响应" aria-hidden="true">#</a></h3><p>典型的 http 会话过程：</p><ul><li>客户端发起建立连接，使用 TCP 时，http 默认端口号是 80</li><li>发送客户端请求</li><li>服务器响应请求</li></ul><p>http 请求和响应都包括：</p><ul><li>start line（起始行） <ul><li>请求的起始行包括： <ul><li>请求方法</li><li>请求 path：可以使用绝对路径，完整 url，域名和可选端口，星花（*代表整个服务器，一般配合 OPTION 使用）</li><li>http 版本号</li></ul></li><li>响应的起始行包括： <ul><li>http 版本号</li><li>响应状态码</li><li>状态文本描述（可以省略）</li></ul></li></ul></li><li>http headers（请求头/响应头）：不区分大小写的字符串紧跟着冒号和一个值</li><li>empty line（空行）</li><li>body 部分</li></ul><h4 id="请求方法" tabindex="-1">请求方法 <a class="header-anchor" href="#请求方法" aria-hidden="true">#</a></h4><p>请求方法：方法是否安全方法及其用法都是约定俗称，实际使用还是看 web 服务器的开发者决定</p><ul><li>GET：请求服务器发送某个资源</li><li>HEAD：与 GET 类似，但是只返回首部，不返回报文主体</li><li>POST：向服务器输入数据</li><li>PUT：向服务器写入</li><li>TRACE：诊断目标资源路径的消息回还</li><li>OPTIONS：请求服务器告知其支持的各种功能 （为什么会自动发送 OPTIONS）</li><li>DELETE：请求删除指定资源</li></ul><h4 id="get-和-post-的区别" tabindex="-1">GET 和 POST 的区别 <a class="header-anchor" href="#get-和-post-的区别" aria-hidden="true">#</a></h4><p>应用场景上，get 是无副作用的，幂等的，post 主要是有副作用的，不幂等的</p><p>技术上：</p><ul><li>缓存：Get 请求能缓存，Post 请求不能</li><li>安全：Get 请求的参数在 url 里，相对不安全，还会被保存历史记录</li><li>限制：url 有长度限制，会干预 get 请求不能</li><li>编码：GET 只能进行 url 编码，只能接收 ASCII 字符，POST 没有限制</li><li>从 TCP 角度看：GET 请求会把请求报文一次性发出去，而 POST 会分成两个数据包，首先发 header 部分，如果服务器响应 100，然后发 body 包（火狐浏览器除外）</li></ul><h4 id="状态码" tabindex="-1">状态码 <a class="header-anchor" href="#状态码" aria-hidden="true">#</a></h4><ul><li>100 ～ 199 信息性状态码</li><li>200 ～ 299 成功</li><li>300 ～ 399 重定向 <ul><li>301 moved permanently 永久重定向</li><li>302 found 临时重定向</li><li>303 see other 资源存在另一个 url 应使用 Get</li><li>304 not modified 可以用缓存</li></ul></li><li>400 ～ 499 客户端错误 <ul><li>400 bad request，请求报文存在语法错误</li><li>401 unauthorized，请求需要有通过 http 认证的认证信息</li><li>403 forbidden，请求被拒绝</li><li>404 not found 服务器上没有找到资源</li></ul></li><li>500 ～ 599 服务器错误 <ul><li>500 internal server error 服务器发生错误</li><li>501 not implemented 服务器不支持当前请求所需要的某个功能</li><li>503 service unavailable 服务器超载或停机维护</li></ul></li></ul><h4 id="首部" tabindex="-1">首部 <a class="header-anchor" href="#首部" aria-hidden="true">#</a></h4><h3 id="http-0-9-1-0-1-1-2-0" tabindex="-1">http 0.9 / 1.0 / 1.1 / 2.0 <a class="header-anchor" href="#http-0-9-1-0-1-1-2-0" aria-hidden="true">#</a></h3><ul><li>0.9 没有响应头，没有状态码，只传输 html 文件</li><li>1.0 有状态码，content-type 告诉客户端返回的内容类型，但是每个 TCP 只能发送一个 http 请求</li></ul><p>http 1.1</p><ul><li>连接可复用：默认开启长连接 connection: keep-alive ，一个 TCP 连接上可以传送多个 HTTP 请求和响应</li><li>增加了管道化技术：还是存在队头阻塞问题</li><li>支持响应分块</li><li>引入额外的缓存控制机制：1.0 里主要使用 If-Modified-Sinc、Expires 判断，1.1 引入了 Entity tag、If-None-Match、Cache-Control 等</li><li>Host 头，不同域名配置同一个 IP 地址等服务器</li></ul><p>http 2.0</p><ul><li>是二进制协议，而不是文本协议 <ul><li>帧：是这个协议通信的最小单位</li><li>消息：比如请求、响应，由一或多个帧组成</li><li>流：虚拟信道</li></ul></li><li>多路复用：分成多个帧发送</li></ul><h3 id="http-缓存" tabindex="-1">http 缓存 <a class="header-anchor" href="#http-缓存" aria-hidden="true">#</a></h3><h4 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-hidden="true">#</a></h4><p>由 Cache-Control 和 Expires 决定</p><p>Cache-Control: max-age=31536000</p><h4 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a></h4><h2 id="https" tabindex="-1">https <a class="header-anchor" href="#https" aria-hidden="true">#</a></h2><h3 id="加密" tabindex="-1">加密 <a class="header-anchor" href="#加密" aria-hidden="true">#</a></h3><h4 id="单向加密" tabindex="-1">单向加密 <a class="header-anchor" href="#单向加密" aria-hidden="true">#</a></h4><p>不可逆加密，对明文产生一个密文，并不能再通过密文解出来对应的明文</p><p>但是输入一样时输出必然相同</p><p>一般用于产生消息摘要，密钥加密、保存验证密码等，比如 md5，SHA</p><h4 id="对称加密" tabindex="-1">对称加密 <a class="header-anchor" href="#对称加密" aria-hidden="true">#</a></h4><p>用一个密钥，对明文进行加密，再用同一个密钥进行解密</p><p>比如 DES 3DES AES</p><h4 id="非对称加密" tabindex="-1">非对称加密 <a class="header-anchor" href="#非对称加密" aria-hidden="true">#</a></h4><p>使用私钥进行加密，使用公钥进行解密，也可以使用公钥加密，私钥解密</p><p>比如 RSA DSA</p><p>特点：</p><ul><li>使用两把密钥进行加密和解密</li><li>一个加密要用另一个解密</li><li>加密和解密速度慢</li><li>私钥和公钥总是成对出现</li></ul><h4 id="进行通讯的场景" tabindex="-1">进行通讯的场景 <a class="header-anchor" href="#进行通讯的场景" aria-hidden="true">#</a></h4><p>如果直接使用非对称加密进行通讯，会非常慢，所以需要使用对称加密的方式进行</p><p>但是对称加密的密钥在传输过程中可能被截取，然后中间人就可以用密钥解密双方消息再加密转发</p><p>所以这个对称加密使用的密钥需要安全传输，就用 非对称加密来传输对称加密使用的密钥</p><p>A 和 B 之间进行非对称加密传输，可以让 B 获取 A 的公钥（公钥是公开的，其他人很容易获取），加密数据后发送给 A，A 再用自己的私钥进行解密</p><p><strong>但是这样依旧存在中间人攻击的可能性</strong></p><p>C 有自己的公钥和私钥，在 B 获取 A 的公钥的过程中进行拦截，让 B 获取的是 C 的公钥，然后 B 发送密钥时使用的其实是 C 的公钥，然后 C 进行拦截，用私钥解密，保存一份，然后将密钥使用 A 的公钥进行加密转发给 A，A 用私钥解密，这样 C 就可以监听 A B 之间的通信了</p><p><strong>数字证书就是为了解决公钥传输问题的</strong></p><ul><li>摘要：md5 或者其他单向加密算法对内容进行加密，得到的字符串就叫摘要</li><li>签名：用私钥对摘要进行加密，加密出来的字符串就叫签名</li><li>验签：用对方公钥对签名进行解密操作，解密的摘要和原来的对比，就叫验签</li></ul><p>数字证书中包含了：</p><ul><li>1.公钥：使用者的公钥</li><li>2.颁发者：CA（证书认证机构）</li><li>3.有效期：证书的使用期限</li><li>4.摘要算法：指定摘要算法，用来计算证书的摘要</li><li>5.指纹：也就是证书的摘要，用来验证证书的完整性</li><li>6.序列号：证书的唯一标识</li></ul><p>然后在前面的例子里，A 有了证书，B 就不用去下载 A 的公钥的，直接 A 传输证书给 B 即可 B 要验证 证书的真实性，就需要用 CA 机构的公钥进行解密，而 CA 机构的公钥不需要去下载，CA 机构的数字证书会内置在操作系统中 此时，B 使用 CA 机构的公钥对 A 传输来的证书里的签名进行解密，得到摘要，然后根据证书的摘要算法进行计算，对比摘要是否相等，如果相等，就说明证书是 CA 机构颁布的</p><h3 id="https-通信的完整过程" tabindex="-1">https 通信的完整过程 <a class="header-anchor" href="#https-通信的完整过程" aria-hidden="true">#</a></h3><ul><li>前置步骤 <ul><li><ol><li>网站向 CA 机构 申请数字证书</li></ol></li><li><ol start="2"><li>CA 机构用自己的私钥加密数字证书并签名，数字证书中存有网站的公钥，将数字证书颁发给对应网站</li></ol></li></ul></li><li>开始通信 <ul><li><ol start="3"><li>浏览器向服务器发送加密请求</li></ol></li><li><ol start="4"><li>服务器响应浏览器，把加密的网页和数字证书一起发送给浏览器</li></ol></li><li><ol start="5"><li>浏览器获取网站的数字证书，对数字证书进行验证，确认是 CA 机构颁发的证书后，使用数字证书中的网站公钥和服务器协商一个对称加密的密钥即可，然后再次访问网站，这个过程就是对称加密了</li></ol></li></ul></li></ul>',64),r=[h];function p(d,n,s,o,u,c){return t(),i("div",null,r)}const m=l(a,[["render",p]]);export{f as __pageData,m as default};
