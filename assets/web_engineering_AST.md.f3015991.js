import{_ as s,c as a,o as l,d as n}from"./app.0a4ff61d.js";const F=JSON.parse('{"title":"AST","description":"","frontmatter":{"title":"AST","lastUpdated":true},"headers":[{"level":2,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":2,"title":"使用 babel 插件","slug":"使用-babel-插件","link":"#使用-babel-插件","children":[]},{"level":2,"title":"最佳实践","slug":"最佳实践","link":"#最佳实践","children":[{"level":3,"title":"尽量避免遍历抽象语法树","slug":"尽量避免遍历抽象语法树","link":"#尽量避免遍历抽象语法树","children":[]}]}],"relativePath":"web/engineering/AST.md","lastUpdated":1678959422000}'),e={name:"web/engineering/AST.md"},p=n(`<h1 id="ast" tabindex="-1">AST <a class="header-anchor" href="#ast" aria-hidden="true">#</a></h1><p><strong>抽象语法树（Abstract Syntax Tree，AST）是源码语法结构的一种树状抽象表示</strong>在代码的语法检查、风格检查、格式化、高亮、错误提示、自动补全等方面均有广泛应用</p><h2 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-hidden="true">#</a></h2><p>编译器整体执行过程分为三步</p><ul><li><p>Parsing:</p><ul><li>词法分析：使用 tokenizer(分词器) 或者 lexer(词法分析器) 将源码拆分为 tokens 存放在一个数组里</li><li>语法分析：将 tokens 重新整理成语法相互关联的表达形式</li><li>构建 AST</li></ul></li><li><p>Transformation：这个过程主要是根据当前 AST 生成一个新的 AST</p><ul><li>对 AST 进行深度优先遍历：Traversal</li><li>通过 Vistor 进行访问（进行修改或者生成新的 AST），访问器对象可以处理不同类型的节点函数</li><li>输出新的 AST</li></ul></li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> visitor </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">NumberLiteral</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">enter</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">node</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">parent</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">exit</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">node</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">parent</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>Code Generation <ul><li>根据新的 AST 进行目标代码生成</li><li>输出新的代码</li></ul></li></ul><h2 id="使用-babel-插件" tabindex="-1">使用 babel 插件 <a class="header-anchor" href="#使用-babel-插件" aria-hidden="true">#</a></h2><ul><li>@babel/parser 可以把源码转换成 AST</li><li>@babel/traverse 用于对 AST 的遍历，维护整棵树的状态，并且负责替换、移除和添加节点</li><li>@babel/generate 可以把 AST 生成源码，同时生成 sourcemap</li><li>@babel/types 用于 AST 节点的 Loadsh 工具库，包含了构造、验证以及变换 AST 节点的方法，对编写处理 AST 逻辑非常有用</li><li>@babel/core Babel 的编译器，核心 API 都在这里，并实现了插件功能</li></ul><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">install</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">@babel/core</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-D</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;"># 里面包含了 @babel/parser @babel/traverse @babel/generate 等</span></span>
<span class="line"></span></code></pre></div><h2 id="最佳实践" tabindex="-1">最佳实践 <a class="header-anchor" href="#最佳实践" aria-hidden="true">#</a></h2><h3 id="尽量避免遍历抽象语法树" tabindex="-1">尽量避免遍历抽象语法树 <a class="header-anchor" href="#尽量避免遍历抽象语法树" aria-hidden="true">#</a></h3><p><strong>遍历 AST 的代价很昂贵，并且容易做出非必要的遍历，可能是数以万计的多余操作</strong></p><p>Babel 对此做出了尽可能的优化，方法是合并多个 visitor ，能够在单次遍历内做完事情的话就合并它们</p><ul><li>及时合并访问者</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">path</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">traverse</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#F07178;">Identifier</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">path</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">path</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">traverse</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#F07178;">BinaryExpression</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">path</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 两个访问器合并</span></span>
<span class="line"><span style="color:#A6ACCD;">path</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">traverse</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#F07178;">Identifier</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">path</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#F07178;">BinaryExpression</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">path</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div><ul><li>可以手动查找就不要遍历</li></ul>`,17),o=[p];function t(r,c,i,D,y,A){return l(),a("div",null,o)}const d=s(e,[["render",t]]);export{F as __pageData,d as default};
