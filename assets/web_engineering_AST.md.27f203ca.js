import{_ as s,c as a,o as l,d as n}from"./app.fd35756a.js";const d=JSON.parse('{"title":"AST","description":"","frontmatter":{},"headers":[{"level":2,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":2,"title":"使用 babel 插件","slug":"使用-babel-插件","link":"#使用-babel-插件","children":[]}],"relativePath":"web/engineering/AST.md","lastUpdated":1677489508000}'),e={name:"web/engineering/AST.md"},o=n(`<h1 id="ast" tabindex="-1">AST <a class="header-anchor" href="#ast" aria-hidden="true">#</a></h1><p><strong>抽象语法树（Abstract Syntax Tree，AST）是源码语法结构的一种树状抽象表示</strong>在代码的语法检查、风格检查、格式化、高亮、错误提示、自动补全等方面均有广泛应用</p><h2 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-hidden="true">#</a></h2><p>编译器整体执行过程分为三步</p><ul><li><p>Parsing:</p><ul><li>词法分析：使用 tokenizer(分词器) 或者 lexer(词法分析器) 将源码拆分为 tokens 存放在一个数组里</li><li>语法分析：将 tokens 重新整理成语法相互关联的表达形式</li><li>构建 AST</li></ul></li><li><p>Transformation：这个过程主要是根据当前 AST 生成一个新的 AST</p><ul><li>对 AST 进行深度优先遍历：Traversal</li><li>通过 Vistor 进行访问（进行修改或者生成新的 AST），访问器对象可以处理不同类型的节点函数</li><li>输出新的 AST</li></ul></li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> visitor </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">NumberLiteral</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">enter</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">node</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">parent</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">exit</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">node</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">parent</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>Code Generation <ul><li>根据新的 AST 进行目标代码生成</li><li>输出新的代码</li></ul></li></ul><h2 id="使用-babel-插件" tabindex="-1">使用 babel 插件 <a class="header-anchor" href="#使用-babel-插件" aria-hidden="true">#</a></h2><ul><li>@babel/parser 可以把源码转换成 AST</li><li>@babel/traverse 用于对 AST 的遍历，维护整棵树的状态，并且负责替换、移除和添加节点</li><li>@babel/generate 可以把 AST 生成源码，同时生成 sourcemap</li><li>@babel/types 用于 AST 节点的 Loadsh 工具库，包含了构造、验证以及变换 AST 节点的方法，对编写处理 AST 逻辑非常有用</li><li>@babel/core Babel 的编译器，核心 API 都在这里，并实现了插件功能</li></ul><div class="language-sh"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">install</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">@babel/core</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">-D</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;"># 里面包含了 @babel/parser @babel/traverse @babel/generate 等</span></span>
<span class="line"></span></code></pre></div>`,10),p=[o];function t(r,i,c,A,D,y){return l(),a("div",null,p)}const b=s(e,[["render",t]]);export{d as __pageData,b as default};
