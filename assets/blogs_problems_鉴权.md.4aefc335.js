import{_ as e,c as i,o,d as s}from"./app.d1919d64.js";const u=JSON.parse('{"title":"鉴权","description":"","frontmatter":{"title":"鉴权","lastUpdated":true},"headers":[{"level":2,"title":"","slug":"","link":"#","children":[]},{"level":2,"title":"HTTP 基本鉴权","slug":"http-基本鉴权","link":"#http-基本鉴权","children":[]},{"level":2,"title":"Session-Cookie 鉴权","slug":"session-cookie-鉴权","link":"#session-cookie-鉴权","children":[{"level":3,"title":"Cookie","slug":"cookie","link":"#cookie","children":[]},{"level":3,"title":"Session","slug":"session","link":"#session","children":[]}]}],"relativePath":"blogs/problems/鉴权.md","lastUpdated":1692005866000}'),l={name:"blogs/problems/鉴权.md"},n=s('<h1 id="鉴权" tabindex="-1">鉴权 <a class="header-anchor" href="#鉴权" aria-hidden="true">#</a></h1><p><a href="https://mp.weixin.qq.com/s/cr-wM827LJCqswJ5qVZ49w" target="_blank" rel="noreferrer">参考</a></p><h2 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h2><ul><li>认证：Identification 根据声明者所特有的识别信息确认声明者身份，比如身份证、指纹、密码等</li><li>授权：Authorization 在信息安全领域指 <code>资源所有者委派执行者</code> 赋予执行者指定范围等资源操作权限，比如门禁卡、web 服务器的 session、web 浏览器的 cookie 机制、token 机制</li><li>鉴权：Authentication 指对于一个声明者所声明的身份权利，进行真实性鉴别确认的过程</li></ul><p>授权和鉴权是两个上下游相匹配的关系，先授权，后鉴权，比如发给你门禁卡是授权，你刷卡进门的时候需要鉴权、校验 session/cookie/token 的合法性和有效性</p><p>认证 ---&gt; 授权 ---&gt; 鉴权 ---&gt; 权限控制</p><h2 id="http-基本鉴权" tabindex="-1">HTTP 基本鉴权 <a class="header-anchor" href="#http-基本鉴权" aria-hidden="true">#</a></h2><p>1.client 发送请求请求一个受限的资源 2.服务器返回 401 Unauthorized 3.client 收到后弹框询问用户 4.确认后携带 Base64 格式的用户名密码再次请求 5.服务器进行身份校验 6.校验成功返回 200 资源，校验失败 返回 403 Forbindden</p><p>不安全，HTTP 传输不安全，Base64 编码也很容易解码，就算无法解码，恶意用户获取认证内容之后也可以使用其不断发起请求，进行重放攻击</p><p>无法主动注销，HTTP 协议没有提供机制清除认证信息</p><p>一般在内部网络使用，或者对安全要求不高时使用</p><h2 id="session-cookie-鉴权" tabindex="-1">Session-Cookie 鉴权 <a class="header-anchor" href="#session-cookie-鉴权" aria-hidden="true">#</a></h2><p>利用服务端的 Session(会话) 和客户端的 Cookie 来实现前后端通信认证模式</p><h3 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-hidden="true">#</a></h3><p>HTTP 是无状态协议，对于事物处理没有记忆功能，每次会话完成时服务端不会保存任何会话信息 所以为了让服务器区分不同的客户端，必须主动维护一个状态，用于告知服务端前后两个请求是否来自同一浏览器</p><p>特点：</p><ol><li>Cookie 存储在客户端，可以随意篡改，不安全</li><li>有大小限制，最大 4kb</li><li>有数量限制，一般一个浏览器对于一个网站只能存不超过 20 个 Cookie，浏览器一般只允许存放 300 个 cookie</li><li>Android 和 IOS 对 Cookie 支持性不好</li><li>Cookie 是不可跨域的，但是一级域名和二级域名是允许共享使用的（靠 domain）</li></ol><h3 id="session" tabindex="-1">Session <a class="header-anchor" href="#session" aria-hidden="true">#</a></h3><p>流程：</p><ol><li>客户端向服务器首次发送请求</li><li>服务器接收到数据并自动为该用户创建特定的 session/session ID 来标识用户并跟踪用户当前的会话过程</li><li>客户端收到响应获取会话信息，并在下一次请求时带上 session/session ID</li><li>服务器提取后与本地保存的 session 进行对比，找到该用户的会话，进而获取会话状态</li><li>至此客户端与服务器的无状态通信变成了有状态通信</li></ol><p>特点： session 保存在服务器上，通过服务器自带的加密协议进行</p><p>与 cookie 的区别：</p><ol><li>安全性：cookie 保存着客户端可以随意篡改，session 存储在服务器端无法伪造</li><li>存取值类型不同：cookie 只支持字符串数据，session 可以存任意类型</li><li>有效期不同：cookie 可以设置为长时间保持，session 一般失效时间较短</li><li>大小：cookie 不超过 4k</li></ol>',23),t=[n];function a(r,d,c,h,p,k){return o(),i("div",null,t)}const f=e(l,[["render",a]]);export{u as __pageData,f as default};
